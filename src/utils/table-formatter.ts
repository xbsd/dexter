/**
 * Table formatter utilities for fixing alignment and adding visual styling.
 *
 * Handles Unicode box-drawing tables generated by LLMs and ensures proper
 * column alignment across different terminal widths.
 */

// ANSI escape codes for terminal colors
export const ANSI = {
  reset: '\x1b[0m',
  bold: '\x1b[1m',
  dim: '\x1b[2m',
  italic: '\x1b[3m',
  underline: '\x1b[4m',

  // Foreground colors
  black: '\x1b[30m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',

  // Bright foreground
  brightBlack: '\x1b[90m',
  brightRed: '\x1b[91m',
  brightGreen: '\x1b[92m',
  brightYellow: '\x1b[93m',
  brightBlue: '\x1b[94m',
  brightMagenta: '\x1b[95m',
  brightCyan: '\x1b[96m',
  brightWhite: '\x1b[97m',

  // Background colors
  bgBlack: '\x1b[40m',
  bgRed: '\x1b[41m',
  bgGreen: '\x1b[42m',
  bgYellow: '\x1b[43m',
  bgBlue: '\x1b[44m',
  bgMagenta: '\x1b[45m',
  bgCyan: '\x1b[46m',
  bgWhite: '\x1b[47m',

  // Bright backgrounds
  bgBrightBlack: '\x1b[100m',
  bgBrightBlue: '\x1b[104m',
};

// Box drawing characters
const BOX = {
  topLeft: '┌',
  topRight: '┐',
  bottomLeft: '└',
  bottomRight: '┘',
  horizontal: '─',
  vertical: '│',
  leftT: '├',
  rightT: '┤',
  topT: '┬',
  bottomT: '┴',
  cross: '┼',

  // Double line variants
  doubleHorizontal: '═',
  doubleVertical: '║',
  doubleTopLeft: '╔',
  doubleTopRight: '╗',
  doubleBottomLeft: '╚',
  doubleBottomRight: '╝',

  // Rounded corners
  roundTopLeft: '╭',
  roundTopRight: '╮',
  roundBottomLeft: '╰',
  roundBottomRight: '╯',
};

interface TableCell {
  content: string;
  width: number;
}

interface ParsedTable {
  headers: string[];
  rows: string[][];
  columnWidths: number[];
}

/**
 * Get the visual width of a string, accounting for ANSI codes and wide characters.
 */
function getVisualWidth(str: string): number {
  // Strip ANSI codes
  const stripped = str.replace(/\x1b\[[0-9;]*m/g, '');
  // Count characters (basic - could be enhanced for full Unicode support)
  let width = 0;
  for (const char of stripped) {
    // CJK characters are typically double-width
    const code = char.charCodeAt(0);
    if (code >= 0x1100 && code <= 0x11FF) width += 2; // Hangul
    else if (code >= 0x3000 && code <= 0x9FFF) width += 2; // CJK
    else if (code >= 0xAC00 && code <= 0xD7AF) width += 2; // Hangul syllables
    else if (code >= 0xF900 && code <= 0xFAFF) width += 2; // CJK compatibility
    else if (code >= 0xFE10 && code <= 0xFE1F) width += 2; // Vertical forms
    else if (code >= 0xFF00 && code <= 0xFFEF) width += 2; // Fullwidth forms
    else width += 1;
  }
  return width;
}

/**
 * Pad a string to a target visual width.
 */
function padToWidth(str: string, targetWidth: number, align: 'left' | 'right' | 'center' = 'left'): string {
  const currentWidth = getVisualWidth(str);
  const padding = targetWidth - currentWidth;

  if (padding <= 0) return str;

  const spaces = ' '.repeat(padding);
  switch (align) {
    case 'right': return spaces + str;
    case 'center': {
      const left = Math.floor(padding / 2);
      const right = padding - left;
      return ' '.repeat(left) + str + ' '.repeat(right);
    }
    default: return str + spaces;
  }
}

/**
 * Detect if content looks like a number (for right-alignment).
 */
function isNumeric(str: string): boolean {
  const trimmed = str.trim();
  // Match numbers, percentages, currency
  return /^[$€£¥]?[\d,]+\.?\d*[%KMBTkmbt]?$/.test(trimmed) ||
    /^[+-]?\d+\.?\d*%?$/.test(trimmed) ||
    /^\([+-]?\d+\.?\d*%?\)$/.test(trimmed); // Negative in parens
}

/**
 * Parse a box-drawing table from text.
 */
function parseTable(text: string): ParsedTable | null {
  const lines = text.split('\n');

  // Find table boundaries
  const tableLines: string[] = [];
  let inTable = false;

  for (const line of lines) {
    if (line.includes('┌') || line.includes('╭') || line.includes('╔')) {
      inTable = true;
    }
    if (inTable) {
      tableLines.push(line);
    }
    if (line.includes('┘') || line.includes('╯') || line.includes('╝')) {
      break;
    }
  }

  if (tableLines.length < 3) return null;

  // Extract rows (lines with │)
  const dataLines = tableLines.filter(l => l.includes('│') && !l.match(/^[─┌┐└┘├┤┬┴┼╭╮╰╯═╔╗╚╝]+$/));

  if (dataLines.length === 0) return null;

  // Parse cells
  const parsedRows = dataLines.map(line => {
    // Split by │ and clean up
    return line.split('│')
      .slice(1, -1) // Remove empty first/last
      .map(cell => cell.trim());
  });

  if (parsedRows.length === 0) return null;

  const headers = parsedRows[0];
  const rows = parsedRows.slice(1);

  // Calculate column widths (max of header and all rows)
  const columnWidths = headers.map((h, i) => {
    const headerWidth = getVisualWidth(h);
    const maxRowWidth = rows.reduce((max, row) =>
      Math.max(max, getVisualWidth(row[i] || '')), 0);
    return Math.max(headerWidth, maxRowWidth);
  });

  return { headers, rows, columnWidths };
}

/**
 * Render a properly aligned and styled table with grey-dark plaid pattern.
 */
function renderTable(parsed: ParsedTable, options: {
  headerColor?: string;
  headerBg?: string;
  borderColor?: string;
  numericColor?: string;
  positiveColor?: string;
  negativeColor?: string;
  roundedCorners?: boolean;
  plaidPattern?: boolean;
} = {}): string {
  const {
    headerColor = ANSI.brightCyan + ANSI.bold,
    headerBg = '\x1b[48;5;236m', // Dark grey background for header
    borderColor = '\x1b[38;5;240m', // Medium grey for borders
    numericColor = ANSI.brightWhite,
    positiveColor = ANSI.brightGreen,
    negativeColor = ANSI.brightRed,
    roundedCorners = true,
    plaidPattern = true,
  } = options;

  const { headers, rows, columnWidths } = parsed;

  // Plaid colors - alternating dark greys
  const bgDark = '\x1b[48;5;235m';   // Darker grey
  const bgLight = '\x1b[48;5;237m';  // Slightly lighter grey
  const bgHeader = '\x1b[48;5;238m'; // Header background

  // Add padding to column widths
  const paddedWidths = columnWidths.map(w => w + 2);

  // Build borders
  const topLeft = roundedCorners ? BOX.roundTopLeft : BOX.topLeft;
  const topRight = roundedCorners ? BOX.roundTopRight : BOX.topRight;
  const bottomLeft = roundedCorners ? BOX.roundBottomLeft : BOX.bottomLeft;
  const bottomRight = roundedCorners ? BOX.roundBottomRight : BOX.bottomRight;

  const topBorder = borderColor + topLeft +
    paddedWidths.map(w => BOX.horizontal.repeat(w)).join(BOX.topT) +
    topRight + ANSI.reset;

  const headerSeparator = borderColor + BOX.leftT +
    paddedWidths.map(w => BOX.horizontal.repeat(w)).join(BOX.cross) +
    BOX.rightT + ANSI.reset;

  const bottomBorder = borderColor + bottomLeft +
    paddedWidths.map(w => BOX.horizontal.repeat(w)).join(BOX.bottomT) +
    bottomRight + ANSI.reset;

  // Render header row with dark background
  const headerRow = borderColor + BOX.vertical + ANSI.reset +
    headers.map((h, colIdx) => {
      const padded = padToWidth(h, paddedWidths[colIdx] - 2, 'center');
      const cellBg = plaidPattern ? (colIdx % 2 === 0 ? bgHeader : bgDark) : '';
      return cellBg + ' ' + headerColor + padded + ANSI.reset + cellBg + ' ' + ANSI.reset;
    }).join(borderColor + BOX.vertical + ANSI.reset) +
    borderColor + BOX.vertical + ANSI.reset;

  // Render data rows with plaid pattern (alternating cells)
  const dataRows = rows.map((row, rowIdx) =>
    borderColor + BOX.vertical + ANSI.reset +
    row.map((cell, colIdx) => {
      const isNum = isNumeric(cell);
      const align = isNum ? 'right' : 'left';
      const padded = padToWidth(cell, paddedWidths[colIdx] - 2, align);

      // Plaid pattern: alternate based on row + column
      const cellBg = plaidPattern
        ? ((rowIdx + colIdx) % 2 === 0 ? bgDark : bgLight)
        : '';

      // Color based on content
      let color = '';
      if (cell.includes('+') || cell.includes('▲')) {
        color = positiveColor;
      } else if (cell.includes('-') && !cell.startsWith('$-')) {
        // Negative change (but not negative currency)
        if (/^-?\d/.test(cell.trim()) || cell.includes('%')) {
          color = negativeColor;
        }
      } else if (isNum) {
        color = numericColor;
      }

      return cellBg + ' ' + color + padded + ANSI.reset + cellBg + ' ' + ANSI.reset;
    }).join(borderColor + BOX.vertical + ANSI.reset) +
    borderColor + BOX.vertical + ANSI.reset
  );

  return [
    topBorder,
    headerRow,
    headerSeparator,
    ...dataRows,
    bottomBorder,
  ].join('\n');
}

/**
 * Find and fix all tables in a text string.
 */
export function formatTables(text: string): string {
  // Match table blocks (from ┌ to ┘)
  const tableRegex = /([ \t]*[┌╭╔][^\n]*\n(?:[ \t]*[│║├┼┤└╰╚─═┬┴][^\n]*\n)*[ \t]*[└╰╚][^\n]*)/g;

  return text.replace(tableRegex, (match) => {
    const parsed = parseTable(match);
    if (!parsed) return match;

    try {
      return renderTable(parsed);
    } catch {
      return match;
    }
  });
}

/**
 * Add color styling to financial text (not just tables).
 */
export function colorizeFinancialText(text: string): string {
  let result = text;

  // Colorize positive percentages and changes
  result = result.replace(/(\+\d+\.?\d*%?)/g, ANSI.brightGreen + '$1' + ANSI.reset);

  // Colorize negative percentages (but not ranges like -5%)
  result = result.replace(/(?<!\d)(-\d+\.?\d*%)/g, ANSI.brightRed + '$1' + ANSI.reset);

  // Colorize currency amounts
  result = result.replace(/(\$[\d,]+\.?\d*[KMBT]?)/gi, ANSI.brightYellow + '$1' + ANSI.reset);

  // Colorize tickers (all caps 1-5 letters)
  result = result.replace(/\b([A-Z]{1,5})\b(?=\s|[,.:)]|$)/g, (match) => {
    // Skip common words
    const skip = ['THE', 'AND', 'FOR', 'NOT', 'ARE', 'BUT', 'HAS', 'HAD', 'YTD', 'TTM', 'MOM', 'YOY'];
    if (skip.includes(match)) return match;
    return ANSI.brightCyan + match + ANSI.reset;
  });

  return result;
}

/**
 * Apply all formatting to LLM output.
 */
export function formatOutput(text: string): string {
  let result = text;

  // Fix table alignment and add colors
  result = formatTables(result);

  // Colorize financial terms
  result = colorizeFinancialText(result);

  return result;
}

/**
 * Create a simple colored table from data with plaid pattern.
 */
export function createColoredTable(
  headers: string[],
  rows: string[][],
  options: { title?: string; plaidPattern?: boolean } = {}
): string {
  const columnWidths = headers.map((h, i) => {
    const headerWidth = getVisualWidth(h);
    const maxRowWidth = rows.reduce((max, row) =>
      Math.max(max, getVisualWidth(row[i] || '')), 0);
    return Math.max(headerWidth, maxRowWidth);
  });

  const parsed: ParsedTable = { headers, rows, columnWidths };

  let result = '';
  if (options.title) {
    result += ANSI.bold + ANSI.brightWhite + options.title + ANSI.reset + '\n';
  }
  result += renderTable(parsed, { plaidPattern: options.plaidPattern ?? true });

  return result;
}
